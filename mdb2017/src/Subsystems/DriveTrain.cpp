// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "CANTalon.h"


#include "DriveTrain.h"
#include "../RobotMap.h"
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
#include "../Commands/TeleopDrive.h"
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

DriveTrain::DriveTrain() : Subsystem("DriveTrain") {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    left1 = RobotMap::driveTrainLeft1;
    left2 = RobotMap::driveTrainLeft2;
    right1 = RobotMap::driveTrainRight1;
    right2 = RobotMap::driveTrainRight2;
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

	leftMotorOutput = 0.0;
	rightMotorOutput = 0.0;

	myType = DriveType_Split;
	HighSpeed = 1.0;
	LowSpeed = 0.75;

}

void DriveTrain::InitDefaultCommand() {
    // Set the default command for a subsystem here.
    // SetDefaultCommand(new MySpecialCommand());
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        SetDefaultCommand(new TeleopDrive());
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
}


// Put methods for controlling this subsystem
// here. Call these from Commands.
void DriveTrain::Stop()
{
	left1->Disable();
	left2->Disable();
	right1->Disable();
	right2->Disable();
}

void DriveTrain::Set_PositionMode()
{
	left1->SetControlMode(CANSpeedController::kPosition);
	right1->SetControlMode(CANSpeedController::kPosition);
	left2->SetControlMode(CANSpeedController::kFollower);
	right2->SetControlMode(CANSpeedController::kFollower);

	left2->Set(1);
	right2->Set(2);

	left1->ClearError();
	right1->ClearError();

	left1->ClearIaccum();
	right1->ClearIaccum();

	left1->Set(0);
	right1->Set(0);

	left2->EnableControl();
	right2->EnableControl();

	left2->Enable();
    right2->Enable();

	left1->EnableControl();
	right1->EnableControl();

    printf("Set_PositionMode ");

}

void DriveTrain::Set_VoltageMode()
{
    left1->SetControlMode(CANSpeedController::kPercentVbus);
    right1->SetControlMode(CANSpeedController::kPercentVbus);
	left2->SetControlMode(CANSpeedController::kFollower);
	right2->SetControlMode(CANSpeedController::kFollower);

	left2->Set(1);
	right2->Set(3);

	left2->EnableControl();
	right2->EnableControl();

	left2->Enable();
	right2->Enable();

    left1->Set(0);
    right1->Set(0);

    left1->EnableControl();
    right1->EnableControl();

    printf("Set_VoltageMode (percentVbus): ");
}

float DriveTrain::Limit(float num)
{
	if (num > 1.0)
	{
		return 1.0;
	}
	if (num < -1.0)
	{
		return -1.0;
	}
	return num;
}

void DriveTrain::SetDriveType(DriveType type)
{
	myType = type;
	switch (myType)
	{
		case DriveType_Arcade:
			SmartDashboard::PutString("DriveType","Arcade");
			Preferences::GetInstance()->PutInt("DriveTrain::DriveType",(int) myType);
			break;
		case DriveType_Tank:
			SmartDashboard::PutString("DriveType","Tank");
			Preferences::GetInstance()->PutInt("DriveTrain::DriveType",(int) myType);
			break;

		case DriveType_Split:
			SmartDashboard::PutString("DriveType","Split");
			Preferences::GetInstance()->PutInt("DriveTrain::DriveType",(int) myType);
			break;
		default:
			SmartDashboard::PutString("DriveType","Invalid");
			break;
	}
}

void DriveTrain::SetDrive(XBOX_AxisState axisState)
{
	bool highspeed = false;
	if (axisState.RTrigger == 0.0)
	{
		highspeed = true;
	} else
	{
		highspeed = false;
	}


	//printf("lsx %f lsy %f  rsx %f rsy %f \n",axisState.Raw_LX, axisState.Raw_LY, axisState.Raw_RX,axisState.Raw_RY);
	switch (myType)
	{
	case DriveType_Arcade:
			Robot::driveTrain->SetDrive_Arcade(axisState.Raw_LX, axisState.Raw_LY, highspeed);
		break;

	case DriveType_Tank:
			Robot::driveTrain->SetDrive_Tank(axisState.Raw_LY, axisState.Raw_RY, highspeed);
			//Robot::driveTrain->SetDrive_Tank(axisState.Raw_RY, axisState.Raw_LY, highspeed);
		break;

	case DriveType_Split:
			Robot::driveTrain->SetDrive_Split(axisState.Raw_LX, axisState.Raw_RY, highspeed);
		break;

	default:

		break;
	}
}


void DriveTrain::SetDrive_Arcade(float x, float y, bool highRate)
{
	float tx, ty;

	tx = Limit(x);   // Left - / Right +
	ty = Limit(y);   // Forward + /Backward -

    printf("Arcade Drive: X %f : Y %f :: ",tx,ty);


	if (right1->GetControlMode() != CANSpeedController::kPercentVbus)
	{
		Set_VoltageMode();
	}

	if (ty > 0.0)  // If moving forward
	{
		if (tx > 0.0) // If turning/rotating right
		{
			leftMotorOutput = ty - tx;
			rightMotorOutput = std::max(ty, tx);
		}
		else if (tx < 0.0) // If turning/rotating left or not moving
		{
			leftMotorOutput = std::max(ty, -tx);
			rightMotorOutput = ty + tx;
		} else
		{
			leftMotorOutput = ty;
			rightMotorOutput = ty;
		}
	}
	else  // If moving backward
	{
		if (tx > 0.0) // If turning/rotating right
		{
			leftMotorOutput = - std::max(-ty, tx);
			rightMotorOutput = ty + tx;
		}
		else if (tx < 0.0) // If turning/rotating left or not moving
		{
			leftMotorOutput = ty - tx;
			rightMotorOutput = - std::max(-ty, -tx);
		} else
		{
			leftMotorOutput = ty;
			rightMotorOutput = ty;
		}
	}

	if (highRate) // Technically high rate is the new slow for Stronghold.  Will change this in the off season.
	{
		left1->Set(leftMotorOutput*HighSpeed);
		right1->Set(rightMotorOutput*HighSpeed);
	} else
	{
		left1->Set(leftMotorOutput*LowSpeed);
		right1->Set(rightMotorOutput*LowSpeed);
	}
/*	float lt1v = left1->GetOutputVoltage();
	float lt1c = left1->GetOutputCurrent();
	float lt2v = left2->GetOutputVoltage();
	float lt2c = left2->GetOutputCurrent();
	float rt1v = right1->GetOutputVoltage();
	float rt1c = right1->GetOutputCurrent();
	float rt2v = right2->GetOutputVoltage();
	float rt2c = right2->GetOutputCurrent();
	float PDP0 = 0;
	float PDP1 = 0;
	float PDP14 = 0;
	float PDP15 = 0;
	if (RobotMap::pDPPowerDistributionPanel.get() != nullptr)
	{
		PDP0 = RobotMap::pDPPowerDistributionPanel->GetCurrent(0);
		PDP1 = RobotMap::pDPPowerDistributionPanel->GetCurrent(1);
		PDP14 = RobotMap::pDPPowerDistributionPanel->GetCurrent(14);
		PDP15 = RobotMap::pDPPowerDistributionPanel->GetCurrent(15);
	}
	printf(" l1(CAN 1/PDP 15) PdpC %f : V %f : C %f :: l2 (CAN 2/PDP 14) PdpC %f : V %f : C %f :: r1(CAN 3/PDP 0) PdpC %f : V %f : C %f :: r2(CAN 4/PDP 1) PdpC %f : V %f : C %f \n", PDP15, lt1v, lt1c, PDP14, lt2v, lt2c, PDP0, rt1v, rt1c, PDP1, rt2v, rt2c);
*/
}


void DriveTrain::SetDrive_Tank(float left, float right, bool highRate)
{
	float tx, ty;

	tx = Limit(left);
	ty = Limit(right);

    printf("Tank Drive: Left %f : Right %f  :: ",tx,ty);

	if (right1->GetControlMode() != CANSpeedController::kPercentVbus)
	{
		Set_VoltageMode();
	}

	leftMotorOutput = tx;
	rightMotorOutput = ty;

	if (highRate)  // Technically high rate is the new slow for Stronghold.  Will change this in the off season.
	{
		left1->Set(leftMotorOutput*HighSpeed);
		right1->Set(rightMotorOutput*HighSpeed);
	} else
	{
		left1->Set(leftMotorOutput*LowSpeed);
		right1->Set(rightMotorOutput*LowSpeed);
	}
/*	float lt1v = left1->GetOutputVoltage();
	float lt1c = left1->GetOutputCurrent();
	float lt2v = left2->GetOutputVoltage();
	float lt2c = left2->GetOutputCurrent();
	float rt1v = right1->GetOutputVoltage();
	float rt1c = right1->GetOutputCurrent();
	float rt2v = right2->GetOutputVoltage();
	float rt2c = right2->GetOutputCurrent();
	float PDP0 = 0;
	float PDP1 = 0;
	float PDP14 = 0;
	float PDP15 = 0;
	if (RobotMap::pDPPowerDistributionPanel.get() != nullptr)
	{
		PDP0 = RobotMap::pDPPowerDistributionPanel->GetCurrent(0);
		PDP1 = RobotMap::pDPPowerDistributionPanel->GetCurrent(1);
		PDP14 = RobotMap::pDPPowerDistributionPanel->GetCurrent(14);
		PDP15 = RobotMap::pDPPowerDistributionPanel->GetCurrent(15);
	}
	printf(" l1(CAN 1/PDP 15) PdpC %f : V %f : C %f :: l2 (CAN 2/PDP 14) PdpC %f : V %f : C %f :: r1(CAN 3/PDP 0) PdpC %f : V %f : C %f :: r2(CAN 4/PDP 1) PdpC %f : V %f : C %f \n", PDP15, lt1v, lt1c, PDP14, lt2v, lt2c, PDP0, rt1v, rt1c, PDP1, rt2v, rt2c);
*/
}

void DriveTrain::SetDrive_Split(float turn, float throttle, bool highRate)
{
	float tx, ty;

	tx = Limit(turn);
	ty = Limit(throttle);

    printf("Split Drive: Turn %f : Throttle %f :: ",tx,ty);


	if (right1->GetControlMode() != CANSpeedController::kPercentVbus)
	{
		Set_VoltageMode();
	}

	if (ty > 0.0) 			// If moving Forward
	{
		if (tx > 0.0)      // If turning/rotating right
		{
			leftMotorOutput = ty - tx;
			rightMotorOutput = std::max(ty, tx);
		}
		else if (tx < 0.0) // If turning/rotating left or not moving
		{
			leftMotorOutput = std::max(ty, -tx);
			rightMotorOutput = ty + tx;
		} else
		{
			leftMotorOutput = ty;
			rightMotorOutput = ty;
		}
	}
	else  // If Moving Backward
	{
		if (tx > 0.0) // If turning/rotating right
		{
			leftMotorOutput = - std::max(-ty, tx);
			rightMotorOutput = ty + tx;
		}
		else if (tx < 0.0) // If turning/rotating left or not moving
		{
			leftMotorOutput = ty - tx;
			rightMotorOutput = - std::max(-ty, -tx);
		} else
		{
			leftMotorOutput = ty;
			rightMotorOutput = ty;
		}
	}

	if (highRate) // Technically high rate is the new slow for Stronghold.  Will change this in the off season.
	{
		left1->Set(leftMotorOutput*HighSpeed);
		right1->Set(rightMotorOutput*HighSpeed);
	} else
	{
		left1->Set(leftMotorOutput*LowSpeed);
		right1->Set(rightMotorOutput*LowSpeed);
	}
/*
	float lt1v = left1->GetOutputVoltage();
	float lt1c = left1->GetOutputCurrent();
	float lt2v = left2->GetOutputVoltage();
	float lt2c = left2->GetOutputCurrent();
	float rt1v = right1->GetOutputVoltage();
	float rt1c = right1->GetOutputCurrent();
	float rt2v = right2->GetOutputVoltage();
	float rt2c = right2->GetOutputCurrent();
	float PDP0 = 0;
	float PDP1 = 0;
	float PDP14 = 0;
	float PDP15 = 0;
	if (RobotMap::pDPPowerDistributionPanel.get() != nullptr)
	{
		PDP0 = RobotMap::pDPPowerDistributionPanel->GetCurrent(0);
		PDP1 = RobotMap::pDPPowerDistributionPanel->GetCurrent(1);
		PDP14 = RobotMap::pDPPowerDistributionPanel->GetCurrent(14);
		PDP15 = RobotMap::pDPPowerDistributionPanel->GetCurrent(15);
	}
	printf(" l1(CAN 1/PDP 15) PdpC %f : V %f : C %f :: l2 (CAN 2/PDP 14) PdpC %f : V %f : C %f :: r1(CAN 3/PDP 0) PdpC %f : V %f : C %f :: r2(CAN 4/PDP 1) PdpC %f : V %f : C %f \n", PDP15, lt1v, lt1c, PDP14, lt2v, lt2c, PDP0, rt1v, rt1c, PDP1, rt2v, rt2c);
*/
}


